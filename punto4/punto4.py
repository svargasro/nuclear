# -*- coding: utf-8 -*-
"""Punto4Edna.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QS7SIFxxIqMXF8DUh263Dn1rXeE3iOTW
"""

#Punto 4a
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve
import seaborn as sns
sns.set_style("whitegrid")
sns.set_context("paper")

plt.rcParams.update({
    'font.family': 'serif',
    'font.size': 11,
    'axes.titlesize': 12,
    'axes.labelsize': 11,
    'xtick.labelsize': 10,
    'ytick.labelsize': 10,
    'legend.fontsize': 10,
})

# Constantes
hbar_c = 197.327  # [MeV*fm]
m_p = 938.3       # [MeV/c^2]
m_n = 939.6       # [MeV/c^2]
mu = (m_p * m_n) / (m_p + m_n)  # [MeV/c^2]
a = 3.0  # [fm]

# Valores de V0
V0_values = [40, 50, 60]

# Ecuación trascendental
def equation(E, V0):
    if E + V0 <= 0 or E >= 0:
        return np.inf
    k = np.sqrt(2 * mu * (E + V0)) / hbar_c
    kappa = np.sqrt(-2 * mu * E) / hbar_c
    return k / np.tan(k * a) + kappa

# Resolver la ecuación
solutions = {}
for V0 in V0_values:
    E_vals = []
    for guess in np.linspace(-V0 + 0.01, -0.01, 100):
        try:
            E_sol = fsolve(equation, guess, args=(V0))[0]
            if -V0 < E_sol < 0:
                if not any(np.isclose(E_sol, E, atol=1e-2) for E in E_vals):
                    E_vals.append(E_sol)
        except:
            continue
    solutions[V0] = sorted(E_vals)

# === Graficar u(r) para V0 = 50 ===
V0 = 50.0  # [MeV]
E = solutions[V0][0]  # Primer estado ligado
k = np.sqrt(2 * mu * (V0 + E)) / hbar_c
kappa = np.sqrt(-2 * mu * E) / hbar_c

# Normalización
A = 1
B = A * np.sin(k * a) / np.exp(-kappa * a)

# Dominios
r_inside = np.linspace(0, a, 300)
r_outside = np.linspace(a, 7, 300)

u_inside = A * np.sin(k * r_inside)
u_outside = B * np.exp(-kappa * r_outside)

# Graficar
plt.plot(r_inside, u_inside, label=r"$u(r)$ dentro del pozo")
plt.plot(r_outside, u_outside, label=r"$u(r)$ fuera del pozo")
plt.axvline(x=a, color='gray', linestyle='--', label=r"$r = a$")
plt.xlabel(r"$r$ [fm]")
plt.ylabel(r"$u(r)$")
plt.title(r"Estado ligado para $V_0 = 50$ MeV, $E \approx %.2f$ MeV" % E)
plt.legend()
plt.tight_layout()
plt.grid(True)
plt.savefig('bound.pdf')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Estilo gráfico
sns.set_style("whitegrid")
sns.set_context("paper", font_scale=1.1)
plt.rcParams["font.family"] = "serif"

# Parámetros
a = 1.0  # fm
r = np.linspace(0, 5, 1000)
hbar2_2m = 1.0  # unidades naturales

# Potenciales y energías
V0_list = [1, 15, 30]  # MeV
E_list = [10, 20, 30]   # MeV

# Funciones de onda por regiones
def u_inside(r, k1):
    return np.sin(k1 * r)

def u_outside(r, k, delta):
    return np.sin(k * r + delta)

# Generar gráficas para cada V0 fijo
for V0 in V0_list:
    plt.figure(figsize=(8, 5))

    for E in E_list:
        # Cálculos
        k1 = np.sqrt(E + V0)
        k = np.sqrt(E)
        kr = k * r

        # Determinar delta (desfase)
        tan_k1a = np.tan(k1 * a)
        delta = np.arctan((k1 / k) * tan_k1a)

        # Solución por regiones
        u = np.piecewise(
            r,
            [r < a, r >= a],
            [lambda r: u_inside(r, k1),
             lambda r: u_outside(r, k, delta)]
        )
        u /= np.max(np.abs(u))  # Normalización

        # Graficar contra kr
        plt.plot(kr, u, label=f"$E={E}$ MeV")

    #plt.title(f"Función de onda radial $u_0(kr)$ para $V_0 = {V0}$ MeV")
    plt.xlabel("$kr$")
    plt.ylabel(f"$u_0(kr)$ (normalizada)")
    plt.legend()
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Estilo gráfico
sns.set_style("whitegrid")
sns.set_context("paper", font_scale=1.1)
plt.rcParams["font.family"] = "serif"

# Parámetros
a = 1.0  # fm
r = np.linspace(0, 5, 1000)
hbar2_2m = 1.0  # unidades naturales

# Potenciales y energías
V0_list = [1, 15, 30]  # MeV
E_list = [10, 20, 30]   # MeV

# Funciones de onda por regiones
def u_inside(r, k1):
    return np.sin(k1 * r)

def u_outside(r, k, delta):
    return np.sin(k * r + delta)

# Generar gráficas para cada V0 fijo
for V0 in V0_list:
    plt.figure(figsize=(8, 5))

    for E in E_list:
        # Cálculos
        k1 = np.sqrt(E + V0)
        k = np.sqrt(E)
        kr = k * r

        # Determinar delta (desfase)
        tan_k1a = np.tan(k1 * a)
        delta = np.arctan((k1 / k) * tan_k1a)

        # Solución por regiones
        u = np.piecewise(
            r,
            [r < a, r >= a],
            [lambda r: u_inside(r, k1),
             lambda r: u_outside(r, k, delta)]
        )
        u /= np.max(np.abs(u))  # Normalización

        # Graficar contra kr
        plt.plot(kr, u, label=f"$E={E}$ MeV")

    #plt.title(f"Función de onda radial $u_0(kr)$ para $V_0 = {V0}$ MeV")
    plt.xlabel("$kr$")
    plt.ylabel(f"$u_0(kr)$ (normalizada)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig(f"noligado{V0}.pdf")

plt.show()